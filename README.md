# leetcode
This is a repository about my leetcode.



# leetcode 算法分析

## 134.加油站

leetcode链接：[134. 加油站 - 力扣（LeetCode）](https://leetcode.cn/problems/gas-station/description/)

#### 问题：

1.在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。

2.你有一辆**油箱容量无限**的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

3.给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的

#### 实例：

```c++
输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
输出: 3
解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。
```

```c++
输入: gas = [2,3,4], cost = [3,4,3]
输出: -1
解释:
你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
因此，无论怎样，你都不可能绕环路行驶一周。
```

#### 理论分析:

1. 最直接的想法：从头到尾遍历每个加油站，检查以该加油站为起点是否能行驶一周。这样会超出时间限制，改变思路。

2. 假设从加油站 x 出发，每经过一个加油站就加一次油（包括起始加油站），最后一个可以到达的加油站是 y（不妨设 x<y）。这就说明第一个式子表明无法到达加油站 y 的下一个加油站，第二个式子表明可以到达 y 以及 *y* 之前的所有加油站。

![fig-134-1](C:\Users\Wislab\Desktop\leetcode算法分析\assets\fig-134-1.png)

3. 现在，考虑任意一个位于 x,y 之间的加油站 z（包括 x 和 y），我们现在考察从该加油站出发，能否到达加油站 y 的下一个加油站。

![fig-134-2](C:\Users\Wislab\Desktop\leetcode算法分析\assets\fig-134-2.png)



​	其中不等式的第二步、第三步分别利用了上面的第一个、第二个不等式。

4. 从上面的推导中，能够得出结论：从 x,y 之间的任何一个加油站出发，都无法到达加油站 y 的下一个加油站。在发现了这一个性质后，算法就很清楚了：我们首先检查第 0 个加油站，并试图判断能否环绕一周；如果不能，就从第一个无法到达的加油站开始继续检查。



#### 代码编写：

```c++
/*
134.加油站解法_1

编写语言：C++
编写时间：2023/10/15
时间复杂度：O(N)   空间复杂度：O(1)

*/
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        //获取加油站个数，n为加油站个数。
        int n=gas.size();
        int i=0;
        //从第0个加油站开始遍历。
        while(i<n){
            //sumofgas是汽车汽油的总汽油量，sumofcost是汽车汽油的总消耗量。
            int sumofgas=0,sumofcost=0;
            //cnt是从第i个加油站开始检查以该加油站为起点是否能行驶一周。
            int cnt=0;
            while(cnt<n){
                //加油站之间是循环的，所以是要%n。
                int j=(i+cnt)%n;
                //每经过一个加油站汽车的总汽油量加上对应的油量。
                sumofgas+=gas[j];
                //每经过一个加油站汽车的汽油总消耗量加上对应的消耗量。
                sumofcost+=cost[j];
                //如果在某一个加油站总消耗量大于总汽油量，说明汽车不能到达该加油站。
                if(sumofcost>sumofgas){
                    break;
                }
                //如果在某一个加油站总消耗量小于总汽油量，说明汽车可以到达该加油站，cnt++判断下一个加油站。
                cnt++;
            } 
            //如果cnt（汽车经过的加油站数）==n（总加油站数），说明可以到达所有加油站，返回起点加油站i。
            if(cnt==n){
                return i;
            }
            //如果cnt（汽车经过的加油站数）！=n（总加油站数），说明该起点加油站i不可以到达所有加油站，接下来以i+cnt+1为起点加油站继续判断。
            else{
                i=i+cnt+1;
            }
        }
        //遍历完所有加油站都不满足要求，返回-1。
        return -1;
    }
};
```

#### 结果分析：（后续更新）



## 55.跳跃游戏

leetcode链接：[55. 跳跃游戏 - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game/description/)

#### 问题：

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 

#### 实例：

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标
```

#### 理论分析：

1.根据题目描述，只要存在一个位置x本身可以到达，并且它最大长度为x+nums[x]>y（终点），那么返回true。

2.依次遍历数组中的每一个位置，并实时维护 **最远可以到达的位置**。

3.如果遍历过程中出现  **最远可以到达的位置**  在  **遍历指针i ** 的位置后面，那么肯定不可达。

#### 代码编写：

```C++
/*
55.跳跃游戏_1

编写语言：C++
编写时间：2023/10/16
时间复杂度：O(N)   空间复杂度：O(1)

*/
class Solution {
public:
    bool canJump(vector<int>& nums) {
        //n为跳跃站点数
        int n=nums.size();
        //max_distance为最远可达距离
        int max_distance=0;
        //i为遍历指针
        for(int i=0;i<n;i++){
            // 最远可以到达的位置在遍历指针的位置后面，那么肯定不可达。
            if(i>max_distance){
                return false;
            }
            //更新最远可达距离
            max_distance=max(i+nums[i],max_distance);
        }
        return true;
    }
};
```

#### 结果分析：
